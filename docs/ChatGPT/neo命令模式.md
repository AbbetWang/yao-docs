# Neo 命令模式

在最新的代码中，yao 实现了 neo command 模式。

neo command 模式是 yao 利用 ai 智能调用后端服务的功能。比如，用户在 neo 聊天框中输入处理命令"帮我生成 10 条测试数据"，yao 就调用后端服务生成 10 条测试数据。

优势与特点：

- 对用户友好，对用户来说，不再需要记住具体的功能菜单入口，只需要在聊天框中自然的描述他的想法。
- Yao 融合了命令与聊天功能，chatgpt 与 yao 无缝集成，在聊天的过程上随时可以调用后端命令。
- 交互性好，前后端的接口使用 SSE 技术，信息的及时性有保证，并且集成了上下文对话功能。
- 扩展性好，yao 把命令的定义接口留给用户，用户可以根据自己的实际需求扩展自己的功能。

## 配置

### 定义命令

一个命令需要包含以下的内容。

- process 回调处理器，处理 ai 返回的数据,在用户确认后调用的处理器。
- actions 在 xgen 界面上的回调操作。
- prepare 准备与 ai 交互的提示词，尽可能准确的描述的你的目的。

在目录/neo 下创建后缀为`.cmd.yml`配置文件。

`/neo/table/data.cmd.yml`

```yaml
# Generate test data for the table

#
# yao run neo.table.Data 帮我生成20条测试数据

# 命令的名称 用于匹配用户的提示请求
name: Generate test data for the table
# 连接器定义
connector: gpt-3_5-turbo
# 用户确认执行命令后yao进行回调的处理器。
process: scripts.table.Data
# 处理器的参数类型与说明
args:
  - name: data # name 用于筛选chatgpt返回的json数据,并作为处理器的参数
    type: Array
    description: The data sets to generate
    required: true # 表示参数是必须的，如果不存在会报错
    default: []
# 命令执行成功后，在xgen上执行的命令，比如这里数据生成后，在xgen界面上自动刷新。
actions:
  - name: TableSearch
    type: 'Table.search'
    payload: {}

# 命令执行的准备处理器
prepare:
  # 在before阶段，处理器可以根据xgen传入的上下文参数生成与ai交互的命令
  before: scripts.table.DataBefore
  # 在after阶段，把ai返回的数据进行格式化处理，在处理器里可以输出到xgen neo助手对话框界面。
  after: scripts.table.DataAfter
  option:
    temperature: 0.8

  # 与chatgpt交互的提示词，角色是system
  prompts:
    - role: system
      # prepare.before处理器返回的json数据{template:''}
      content: '{{ template }}'

    - role: system
      # prepare.before处理器返回的json数据{explain:''}
      content: '{{ explain }}'

    - role: system
      content: |
        - According to my description, according to the template given to you, generate a similar JSON data.
        - The Data is what I want to generate by template.
        - Reply to me with a message in JSON format only: {"data": "<Replace it with the test data generated by the template>"}
        - Do not explain your answer, and do not use punctuation.
# 命令的描述 用于匹配用户的提示请求
description: |
  Generate test data for the table

optional:
  #用户确认命令后回调的service脚本函数，比如/services/neo.js中的Exec方法
  confirm: neo.Exec
  autopilot: true
```

## 配置聊天 api guard

参考[内置 neo 聊天服务](./neo%E5%8A%A9%E6%89%8B.md)

## neo 助手初始化过程

- 检查内置的聊天记录表是否存在，如果不存在创建新表，默认的表名是 yao_neo_conversation。这个表可以在 neo.yml 配置文件中进行修改。

- 初始化聊天机器人的驱动，模型根据 neo.yml 配置的 connector，默认是使用 chatgpt 的 gpt-3_5-turbo 模型。

- 加载用户的命令列表`*.cmd.yml, *.cmd.yaml`到内存中。

- 用户在 neo 聊天框中输入消息。

## 用户应答过程

### API 响应用户请求

- api guard 中解析出`__sid`作为聊天上下文 id。
- 根据 sid 查找用户的聊天历史，查找表 yao_neo_conversation，聊天历史可以通过配置控制长度。如果是新的会话，聊天历史会是空的。
- 在聊天消息中加入用户最新的请求,比如，“帮我生成一条数据”
- 根据用户最后的输入消息中是否包含了命令。

用户命令的匹配过程如下：

### 检查请求与命令是否匹配。

neo 助手的每一次请求都会携带两个当前界面组件的信息。`path` 与 `stack` 属性。path 是 neo 助手发送命令时界面的 url 地址，stack 是 xgen 界面组件在界面上的层次关系。

```json
{ "Stack": "Table-Page-pet", "Path": "/x/Table/pet" }
```

这两个参数会跟 所有 cmd.yml 中配置的 path 与 stack 属性进行比较。可以使用通配符`*`,命令中如果没有配置两个参数是匹配所有请求。

把所有的匹配到的命令列表的名称 name 与描述 description，还有用户的请求消息一起提交给 chatgpt 作判断。如果匹配成功，返回处理命令 cmd 的 id。

所以，一个命令是否匹配的上，取决于 3 个因素

- cmd.yml 中配置的`path`与`stack`属性与请求中的`path`与`stack`属性的匹配度。
- cmd.yml 中名称与描述与用户请求消息的匹配度。
- chatgpt 的判断。

### 命令执行过程

成功匹配到命令后，会进入命令处理环节。

- 准备与 chatgpt 交互的提示词。

  - 调用处理器 prepareBefore，获取用户定义的模板内容。

    ```js
    /**
     * Command neo.table.data
     * Prepare Hook: Before
     * @param {*} context  上下文，包含stack/path
     * @param {*} messages 聊天消息历史
     */
    function DataBefore(context, messages) {
      // console.log("DataBefore:", context, messages);
      context = context || { stack: '-', path: '-' };
      messages = messages || [];
      const { path } = context;
      if (path === undefined) {
        done('Error: path not found.\n');
        return false;
      }

      const tpl = Templates[path];
      if (tpl === undefined) {
        done(`Error: ${path} template not found.\n`);
        return false;
      }

      ssWrite(`Found the ${path} generate rules\n`);
      return { template: tpl.data, explain: tpl.explain };
    }
    ```

  - 把处理 prepareBefore 返回的内容与 cmd.prepare 中的 prompt 模板进行合并成新的提示模板。这里可以使用`{{}}`语法绑定。
  - 合并提示模板(system)与用户提问消息(user)，向 chatgpt 提交请求。
  - 调用处理器 prepareAfter。

  ```js
  /**
   * Command neo.table.data
   * Prepare Hook: After
   * @param {*} content chatgpt返回消息
   */
  function DataAfter(content) {
    // console.log("DataAfter:", content);
    const response = JSON.parse(content);
    const data = response.data || [];
    if (data.length > 0) {
      // Print data preview
      //ssWrite向客户端发送sse消息
      ssWrite(`\n`);
      ssWrite(`| name | type | status | mode | stay | cost | doctor_id |\n`);
      ssWrite(`| ---- | ---- | ------ | ---- | ---- | ---- | --------- |\n`);
      data.forEach((item) => {
        message = `| ${item.name} |  ${item.type} |  ${item.status} | ${item.mode} | ${item.stay} | ${item.cost} | ${item.doctor_id}|\n`;
        ssWrite(message);
      });
      ssWrite(`  \n\n`);

      //返回新的消息
      return response;
    }

    throw new Exception('Error: data is empty.', 500);
  }
  ```

  - 根据`Command.Args`解析出返回数据中的参数。

  ```js
  // validate the args
  if req.Command.Args != nil && len(req.Command.Args) > 0 {
  	for _, arg := range req.Command.Args {
  		v, ok := data[arg.Name]
  		if arg.Required && !ok {
  			err := fmt.Errorf("\nMissing required argument: %s", arg.Name)
  			return nil, err
  		}

  		// @todo: validate the type
  		args = append(args, v)
  	}
  }
  ```

  - 如果配置了`Command.Optional.Confirm`，配置项将作为 yao service 函数名，把上一步解析出来的数据作为最后处理器的参数，生成一个新的名称为`ExecCommand`的`Action`。这个`Action`的默认类型是`Service.neo`，即是调用 services 目录下的脚本文件 neo.js。

  ```go
    //yao/neo/command/request.go
    // confirm the command
    func (req *Request) confirm(args []interface{}, cb func(msg *message.JSON) int) {

        service := strings.Split(req.Command.Optional.Confirm, ".")
        if len(service) == 0 {
            service = []string{"neo", "Exec"}
        } else if len(service) == 1 {
            service = []string{"neo", service[0]}
        }

        payload := map[string]interface{}{
            "method": service[1],
            "args": []interface{}{
                req.id,
                req.Command.Process,//处理器函数
                args,
            },
        }

        msg := req.msg().
            Action("ExecCommand", fmt.Sprintf("Service.%s", service[0]), payload, "").
            Confirm().
            Done()

        if req.Actions != nil && len(req.Actions) > 0 {
            for _, action := range req.Actions {
                msg.Action(action.Name, action.Type, action.Payload, action.Next)
            }
        }

        cb(msg)
    }
  ```

  如果`/services/neo.js` 不存在，需要手工创建。为什么不直接调用 process,而是需要中间多一层 service 函数。因为在 xgen 上是无法直接调用后端的 process 处理器，需要使用 service 函数作为中间层。

  ```js
  /**
   * Execute a process
   * @param {*} id
   * @param {*} process cmd中配置的处理器。
   * @param {*} payload
   * @returns
   */
  function Exec(id, process, args) {
    const res = Process(process, ...args);
    return { id: id, result: res };
  }
  ```

- 如果配置了`Command.Actions`，合并 actions，并通过 sse 发送到客户端。

### 用户确认命令

经过上面的处理，在 xgen 的 neo 助手界面上会显示提示消息："消息包含业务指令，是否执行？"。当用户点击执行后，会依次调用上面配置的 actions。

- 调用 action `Service.neo`，会调用服务端的`/services/neo.js`中的`Exec`方法，插入新的数据。
- 调用 action `Table.search`,刷新 table 界面，显示最新的 table 数据。

## 示例代码

```sh
git clone https://github.com/YaoApp/yao-neo-dev.git

```

## 缺点

- ai 并不一定百分百匹配到命令。
- 命令的配置内容比较多。
- 提示词设置需要十分小心。
